"use client";

import { Page, QueryParams } from "@arqiva/react-component-lib";
import routes from "@/lib/routes";
import MetersInner, { MetersFilters } from "./Inner";
import { useEffect, useState, useRef } from "react";
import { PageBreadcrumbs } from "@arqiva/react-component-lib/templates";
import styles from "./index.module.css";

const MetersPage = () => {
  const [metersFilters, setMetersFilters] = useState<MetersFilters>({});
  const [mounted, setMounted] = useState(false);
  const [isScrolled, setIsScrolled] = useState(false);
  const filterBarRef = useRef<HTMLDivElement>(null);

  useEffect(() => setMounted(true), []);

  useEffect(() => {
    const handleScroll = () => {
      const scrollTop = window.scrollY || document.documentElement.scrollTop;
      setIsScrolled(scrollTop > 10);
    };

    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  if (!mounted) return null;

  return (
    <QueryParams.Root>
      <Page.Root>
        <Page.Head>
          <PageBreadcrumbs
            crumbs={[
              {
                label: "Dashboard",
                href: routes.dashboard.root,
              },
            ]}
            page="Meters"
          />

          <Page.TitleWrapper>
            <Page.Title>Meters</Page.Title>
          </Page.TitleWrapper>
        </Page.Head>

        <section className={styles.meters}>
          <div className={styles["meters--full-width"]}>
            <div
              ref={filterBarRef}
              className={`${styles["meters__filters-bar-wrapper"]} ${
                isScrolled
                  ? styles["meters__filters-bar-wrapper--scrolled"]
                  : ""
              }`}
            >
              <div>
                <MetersInner.FiltersBar onFiltersChange={setMetersFilters} />
              </div>
            </div>

            <div
              className={styles["meters__content-wrapper"]}
              style={{ paddingTop: `1rem` }}
            >
              <MetersInner.Content metersFilters={metersFilters} />
            </div>
          </div>
        </section>
      </Page.Root>
    </QueryParams.Root>
  );
};

export default MetersPage;

"use client";

import { useEffect, useRef, useMemo } from "react";
import { QueryParams, useQueryParams } from "@arqiva/react-component-lib";
import {
  DateRangeFilter,
  dateRangeFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/DateRangeFilter";
import {
  MetersFilter,
  meterFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/MetersFilter";
import { useCustomerContext } from "@/app/_components/CustomerProvider";
import KpiSummary from "./widgets/KpiSummary/page";
import MedianVsWeek from "./widgets/MedianVsWeek/page";
import LeakageHistory from "./widgets/LeakageHistory/page";
import DailyUsage from "./widgets/DailyUsage/page";
import ConsumptionTrend from "./widgets/ConsumptionTrend/page";
import styles from "./index.module.css";

const DASHBOARD_FILTERS_KEY = "dashboard-filters";
const METERS_FILTERS_KEY = "meters-filters";

interface DashboardFilters {
  group_id?: string;
  dateRange?: string;
  timeRange?: string;
  consumption_range?: string;
}

const saveFiltersToStorage = (filters: MetersFilters) => {
  try {
    localStorage.setItem(METERS_FILTERS_KEY, JSON.stringify(filters));
  } catch {
    // Silently fail for localStorage errors
  }
};

const loadFiltersFromStorage = (): MetersFilters | null => {
  try {
    const stored = localStorage.getItem(METERS_FILTERS_KEY);
    return stored ? JSON.parse(stored) : null;
  } catch {
    return null;
  }
};

const loadDashboardFiltersFromStorage = (): DashboardFilters | null => {
  try {
    const stored = localStorage.getItem(DASHBOARD_FILTERS_KEY);
    return stored ? JSON.parse(stored) : null;
  } catch {
    return null;
  }
};

export interface MetersFilters {
  meter_id?: string;
  dateRange?: string;
}

interface FiltersBarProps {
  onFiltersChange: (filters: MetersFilters) => void;
}

const FiltersBar = ({ onFiltersChange }: FiltersBarProps) => {
  const { queryParams, setParam, clearAllParams } = useQueryParams();
  const { effectiveCustomerId } = useCustomerContext();
  const previousFiltersRef = useRef<MetersFilters>({});
  const hasRestoredRef = useRef(false);
  const userModifiedDateRangeRef = useRef(false);
  const previousCustomerIdRef = useRef<string>(effectiveCustomerId);

  useEffect(() => {
    if (previousCustomerIdRef.current !== effectiveCustomerId) {
      previousCustomerIdRef.current = effectiveCustomerId;

      clearAllParams();

      hasRestoredRef.current = false;
      userModifiedDateRangeRef.current = false;
      previousFiltersRef.current = {};
    }
  }, [effectiveCustomerId, clearAllParams]);

  const isGeneralMetersPage = useMemo(() => {
    const urlPath = window.location.pathname;
    return urlPath.endsWith("/meters") && !urlPath.match(/\/meters\/[^/]+$/);
  }, []);

  useEffect(() => {
    const urlPath = window.location.pathname;
    const meterIdMatch = urlPath.match(/\/meters\/([^/]+)$/);
    if (meterIdMatch && !queryParams.meter_id) {
      const urlMeterId = meterIdMatch[1];
      setParam("meter_id", urlMeterId);
    }
  }, [queryParams.meter_id, setParam]);

  useEffect(() => {
    const hasAnyFilterParams = queryParams.meter_id || queryParams.dateRange;

    if (!hasAnyFilterParams) {
      const timer = setTimeout(() => {
        try {
          localStorage.removeItem(METERS_FILTERS_KEY);
        } catch {
          // Silently fail
        }
      }, 100);

      return () => clearTimeout(timer);
    }
  }, [queryParams.meter_id, queryParams.dateRange]);

  useEffect(() => {
    if (isGeneralMetersPage) return;

    const storedDashboardFilters = loadDashboardFiltersFromStorage();
    const dashboardDateRange = storedDashboardFilters?.dateRange;

    // Don't override if user is actively selecting a date (partial range exists)
    const isPartialSelection =
      typeof queryParams.dateRange === "string" &&
      queryParams.dateRange.includes("_to_") &&
      !queryParams.dateRange.split("_to_")[1];

    if (
      !userModifiedDateRangeRef.current &&
      dashboardDateRange &&
      queryParams.dateRange !== dashboardDateRange &&
      !isPartialSelection
    ) {
      setParam("dateRange", dashboardDateRange);
    }
  }, [
    isGeneralMetersPage,
    queryParams.meter_id,
    setParam,
    queryParams.dateRange,
  ]);

  useEffect(() => {
    if (hasRestoredRef.current) return;

    const hasAnyCurrentParams = Object.keys(queryParams).some(
      (key) =>
        queryParams[key] !== undefined &&
        queryParams[key] !== null &&
        queryParams[key] !== ""
    );

    if (hasAnyCurrentParams) {
      hasRestoredRef.current = true;
      return;
    }

    const storedMetersFilters = loadFiltersFromStorage();
    const storedDashboardFilters = loadDashboardFiltersFromStorage();

    const dateRangeToRestore = storedDashboardFilters?.dateRange;
    if (dateRangeToRestore) {
      setParam("dateRange", dateRangeToRestore);
    }

    if (storedMetersFilters?.meter_id && !queryParams.meter_id) {
      setParam("meter_id", storedMetersFilters.meter_id);
    }

    hasRestoredRef.current = true;
  }, [isGeneralMetersPage, setParam, queryParams]);

  useEffect(() => {
    const currentFilters = {
      meter_id: queryParams.meter_id ? String(queryParams.meter_id) : undefined,
      dateRange: queryParams.dateRange
        ? String(queryParams.dateRange)
        : undefined,
    };

    const filtersChanged =
      currentFilters.meter_id !== previousFiltersRef.current?.meter_id ||
      currentFilters.dateRange !== previousFiltersRef.current?.dateRange;

    if (filtersChanged) {
      const storedDashboardFilters = loadDashboardFiltersFromStorage();
      if (
        currentFilters.dateRange &&
        currentFilters.dateRange !== storedDashboardFilters?.dateRange
      ) {
        userModifiedDateRangeRef.current = true;
      } else {
        userModifiedDateRangeRef.current = false;
      }

      previousFiltersRef.current = currentFilters;

      const filtersToSave: MetersFilters = {};

      if (currentFilters.meter_id) {
        filtersToSave.meter_id = currentFilters.meter_id;
      }

      saveFiltersToStorage(filtersToSave);
      onFiltersChange(currentFilters);
    }
  }, [
    queryParams.meter_id,
    queryParams.dateRange,
    onFiltersChange,
    isGeneralMetersPage,
  ]);

  return (
    <div className={styles.meters__filters}>
      <QueryParams.Params.Filters>
        <MetersFilter />
        <DateRangeFilter />
      </QueryParams.Params.Filters>
      <QueryParams.Params.SelectedValues
        resultsLoading={false}
        filterOverrides={{
          ...meterFilterOverride,
          ...dateRangeFilterOverride,
        }}
        filterIgnoreList={["q", "page", "perPage", "sortBy", "sortDir"]}
      />
    </div>
  );
};

const Content = ({ metersFilters }: { metersFilters: MetersFilters }) => (
  <section className={styles.meters}>
    <div className={styles["meters--full-width"]}>
      <KpiSummary meterId={metersFilters.meter_id} />
    </div>

    <div className={styles["meters__split-row"]}>
      <div className={styles["meters__main-column"]}>
        <h3 className={styles["meters__section-heading"]}>Consumption Trend</h3>
        <ConsumptionTrend meterId={metersFilters.meter_id} />
      </div>
      <div className={styles["meters__side-column"]}>
        <h3 className={styles["meters__section-heading"]}>
          Median vs this weeks consumption
        </h3>
        <MedianVsWeek meterId={metersFilters.meter_id} />
      </div>
    </div>

    <div className={styles["meters__split-row"]}>
      <div className={styles["meters__main-column"]}>
        <h3 className={styles["meters__section-heading"]}>Leakage History</h3>
        <LeakageHistory meterId={metersFilters.meter_id} threshold={0.5} />
      </div>
      <div className={styles["meters__side-column"]}>
        <h3 className={styles["meters__section-heading"]}>Daily Usage</h3>
        <DailyUsage meterId={metersFilters.meter_id} />
      </div>
    </div>
  </section>
);

const MetersInner = { FiltersBar, Content };
export default MetersInner;

meters/[id]
// @ts-nocheck
"use client";

import { Page, QueryParams } from "@arqiva/react-component-lib";
import { PageBreadcrumbs } from "@arqiva/react-component-lib/templates";
import routes from "@/lib/routes";
import MetersInner, { MetersFilters } from "../Inner";
import { useEffect, useState, useRef } from "react";
import { useParams } from "next/navigation";
import styles from "../index.module.css";

const MeterDetailPage = () => {
  const params = useParams();
  const meterId = params?.id as string;

  const [metersFilters, setMetersFilters] = useState<MetersFilters>({
    meter_id: meterId,
  });
  const [mounted, setMounted] = useState(false);
  const [isScrolled, setIsScrolled] = useState(false);
  const filterBarRef = useRef<HTMLDivElement>(null);

  useEffect(() => setMounted(true), []);

  useEffect(() => {
    const handleScroll = () => {
      const scrollTop = window.scrollY || document.documentElement.scrollTop;
      setIsScrolled(scrollTop > 10);
    };

    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  useEffect(() => {
    if (meterId) {
      setMetersFilters((prev) => ({
        ...prev,
        meter_id: meterId,
      }));
    }
  }, [meterId]);

  if (!mounted) return null;

  return (
    <QueryParams.Root>
      <Page.Root>
        <Page.Head>
          <PageBreadcrumbs
            crumbs={[
              {
                label: "Dashboard",
                href: routes.dashboard.root,
              },
            ]}
            page="Meters"
          />

          <Page.TitleWrapper>
            <Page.Title>Meters</Page.Title>
          </Page.TitleWrapper>
        </Page.Head>

        <section className={styles.meters}>
          <div className={styles["meters--full-width"]}>
            <div
              ref={filterBarRef}
              className={`${styles["meters__filters-bar-wrapper"]} ${
                isScrolled
                  ? styles["meters__filters-bar-wrapper--scrolled"]
                  : ""
              }`}
            >
              <div>
                <MetersInner.FiltersBar onFiltersChange={setMetersFilters} />
              </div>
            </div>

            <div
              className={styles["meters__content-wrapper"]}
              style={{ paddingTop: `1rem` }}
            >
              <MetersInner.Content metersFilters={metersFilters} />
            </div>
          </div>
        </section>
      </Page.Root>
    </QueryParams.Root>
  );
};

export default MeterDetailPage;
"use client";

import { useEffect, useRef } from "react";
import { QueryParams, useQueryParams } from "@arqiva/react-component-lib";
import { useCustomerContext } from "@/app/_components/CustomerProvider";
import {
  GroupFilter,
  groupFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/GroupFilter";
import {
  DateRangeFilter,
  dateRangeFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/DateRangeFilter";
import {
  TimeFilter,
  timeFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/TimeFilter";
import {
  ConsumptionFilter,
  consumptionFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/ConsumptionFilter";
import MeterConsumptionPage from "./widgets/meterConsumption/page";
import LeakagePage from "./widgets/leakgaeInfo/page";
import Top10MeterPage from "./widgets/top10Meters/page";
import FlowValuesInner from "./widgets/flowValues/Inner";
import styles from "./index.module.css";

const DASHBOARD_FILTERS_KEY = "dashboard-filters";

const saveFiltersToStorage = (filters: DashboardFilters) => {
  try {
    localStorage.setItem(DASHBOARD_FILTERS_KEY, JSON.stringify(filters));
  } catch {
    // Silently fail for localStorage errors
  }
};

const loadFiltersFromStorage = (): DashboardFilters | null => {
  try {
    const stored = localStorage.getItem(DASHBOARD_FILTERS_KEY);
    return stored ? JSON.parse(stored) : null;
  } catch {
    return null;
  }
};

export interface DashboardFilters {
  group_id?: string;
  dateRange?: string;
  timeRange?: string;
  consumption_range?: string;
}

interface FiltersBarProps {
  onFiltersChange: (filters: DashboardFilters) => void;
}

const FiltersBar = ({ onFiltersChange }: FiltersBarProps) => {
  const { queryParams, setParam, clearAllParams } = useQueryParams();
  const { effectiveCustomerId } = useCustomerContext();
  const hasRestoredRef = useRef(false);
  const previousCustomerIdRef = useRef<string>(effectiveCustomerId);

  useEffect(() => {
    if (previousCustomerIdRef.current !== effectiveCustomerId) {
      previousCustomerIdRef.current = effectiveCustomerId;

      clearAllParams();

      hasRestoredRef.current = false;
    }
  }, [effectiveCustomerId, clearAllParams]);

  useEffect(() => {
    const hasAnyParams = Object.keys(queryParams).some(
      (key) =>
        queryParams[key] !== undefined &&
        queryParams[key] !== null &&
        queryParams[key] !== ""
    );

    if (!hasAnyParams) {
      const timer = setTimeout(() => {
        try {
          localStorage.removeItem(DASHBOARD_FILTERS_KEY);
          localStorage.removeItem("meters-filters");
        } catch {
          // Silently fail
        }
      }, 100);

      return () => clearTimeout(timer);
    }
  }, [queryParams]);

  useEffect(() => {
    if (hasRestoredRef.current) return;

    const hasAnyCurrentParams = Object.keys(queryParams).some(
      (key) =>
        queryParams[key] !== undefined &&
        queryParams[key] !== null &&
        queryParams[key] !== ""
    );

    if (hasAnyCurrentParams) {
      hasRestoredRef.current = true;
      return;
    }

    const storedFilters = loadFiltersFromStorage();
    if (storedFilters) {
      if (storedFilters.group_id) setParam("group_id", storedFilters.group_id);
      if (storedFilters.dateRange)
        setParam("dateRange", storedFilters.dateRange);
      if (storedFilters.timeRange)
        setParam("timeRange", storedFilters.timeRange);
      if (storedFilters.consumption_range)
        setParam("consumption_range", storedFilters.consumption_range);
    }

    hasRestoredRef.current = true;
  }, [setParam, queryParams]);

  useEffect(() => {
    const currentFilters = {
      group_id: queryParams.group_id ? String(queryParams.group_id) : undefined,
      dateRange: queryParams.dateRange
        ? String(queryParams.dateRange)
        : undefined,
      timeRange: queryParams.timeRange
        ? String(queryParams.timeRange)
        : undefined,
      consumption_range: queryParams.consumption_range
        ? String(queryParams.consumption_range)
        : undefined,
    };

    saveFiltersToStorage(currentFilters);
    onFiltersChange(currentFilters);
  }, [
    queryParams.group_id,
    queryParams.dateRange,
    queryParams.timeRange,
    queryParams.consumption_range,
    onFiltersChange,
  ]);

  return (
    <div className={styles.dashboard__filters}>
      <QueryParams.Params.Filters>
        <GroupFilter />
        <DateRangeFilter />
        <TimeFilter />
        <ConsumptionFilter />
      </QueryParams.Params.Filters>
      <QueryParams.Params.SelectedValues
        resultsLoading={false}
        filterOverrides={{
          ...groupFilterOverride,
          ...dateRangeFilterOverride,
          ...timeFilterOverride,
          ...consumptionFilterOverride,
        }}
        filterIgnoreList={["q"]}
      />
    </div>
  );
};

const Content = () => (
  <section className={styles.dashboard}>
    <div className={styles["dashboard--full-width"]}>
      <h2 className={styles["dashboard__section-heading"]}>
        Meter Consumption
      </h2>
      <MeterConsumptionPage />
    </div>
    <div className={styles["dashboard--full-width"]}>
      <h2 className={styles["dashboard__section-heading"]}>Leakage</h2>
      <LeakagePage />
    </div>
    <div className={styles["dashboard__split-row"]}>
      <div className={styles["dashboard__main-column"]}>
        <h2 className={styles["dashboard__section-heading"]}>Top 10 Meters</h2>
        <Top10MeterPage />
      </div>
      <div className={styles["dashboard__side-column"]}>
        <h2 className={styles["dashboard__section-heading"]}>Flow Values</h2>
        <FlowValuesInner />
      </div>
    </div>
  </section>
);

const DashboardInner = { FiltersBar, Content };
export default DashboardInner;

import Top10MetersPageInner from "./Inner";

export default function Top10MeterPage() {
  return <Top10MetersPageInner />;
}
"use client";

import { useMemo } from "react";
import { useQueryParams } from "@arqiva/react-component-lib";
import { ListTop10Meters } from "@/lib/services/api/dashboard/Kpis/components/Meters/List/List";
import type { Top10MetersResponse } from "@/lib/services/api/dashboard/Kpis/models/getTop10Meters";
import { mapKpiQueryParams } from "@/lib/services/api/dashboard/Kpis/utils/queryParamMapper";
import { useCustomerContext } from "@/app/_components/CustomerProvider";

export default function Top10MetersPageInner({
  initialData,
}: {
  initialData?: Top10MetersResponse;
}) {
  const { queryParams } = useQueryParams();
  const { effectiveCustomerId } = useCustomerContext();

  const queryParameters = useMemo(
    () => ({
      ...mapKpiQueryParams(queryParams, "top10"),
      customer_id: effectiveCustomerId,
    }),
    [queryParams, effectiveCustomerId]
  );

  return (
    <ListTop10Meters
      initialData={initialData}
      queryParameters={queryParameters}
    />
  );
}
"use client";

import { Table, DataTable } from "@arqiva/react-component-lib";
import { top10Columns } from "./columns";
import type {
  Top10MetersResponse,
  Top10MetersRequest,
} from "../../../models/getTop10Meters";
import { useTop10Meters } from "../../../hooks/useTop10Meters";
import { isQueryLoading } from "@/utils/query/isQueryLoading";
import Error from "@/lib/services/api/_components/Error";
import styles from "./index.module.css";

interface ListProps {
  queryParameters: Top10MetersRequest;
  initialData?: Top10MetersResponse;
  children?: ({
    resultsLoading,
    resultsCount,
  }: {
    resultsLoading: boolean;
    resultsCount: number;
  }) => React.ReactNode;
}

export const ListTop10Meters = ({
  queryParameters,
  initialData,
  children,
}: ListProps) => {
  const query = useTop10Meters({
    queryParameters,
    initialData,
  });

  if (query.error) {
    return (
      <Error error={query.error as Error} refetchOptions={query.refetch} />
    );
  }

  const isLoading = isQueryLoading(query);

  return (
    <div className={styles["top-ten-table"]}>
      <Table.Wrapper>
        {children?.({
          resultsLoading: isLoading,
          resultsCount: query.data?.items?.length ?? 0,
        })}

        <DataTable
          columns={top10Columns}
          data={query.data?.items ?? []}
          isLoading={isLoading}
          loader={{ pageLength: 10, widths: ["lg", "md"] }}
        />
      </Table.Wrapper>
      <div className="" style={{ height: "1rem" }}></div>
    </div>
  );
};
"use client";

import { ColumnDef } from "@tanstack/react-table";
import type { Top10MeterEntry } from "../../../models/getTop10Meters";
import {
  Button,
  HorizontalBar,
  Table,
  TruncatedText,
} from "@arqiva/react-component-lib";
import Link from "next/link";
import routes from "@/lib/routes";
import styles from "./index.module.css";

export const top10Columns: ColumnDef<Top10MeterEntry>[] = [
  {
    id: "label",
    header: "Meter ID",
    accessorKey: "label",
    enableSorting: false,
    size: 70,
    cell: ({ row }) => {
      return (
        <div className={styles["top-ten-table__cell"]}>
          <Table.Block.Lead className={styles["top-ten-table__meter"]}>
            <Button
              variant="text"
              asChild
              className={styles["top-ten-table__button"]}
            >
              <Link
                href={routes.dashboard.meterDetails(String(row.original.label))}
              >
                <TruncatedText text={String(row.original.label)} />
              </Link>
            </Button>
          </Table.Block.Lead>
        </div>
      );
    },
  },
  {
    id: "amount",
    header: "Amount",
    accessorKey: "x",
    enableSorting: false,
    cell: ({ row, table }) => {
      const data = [
        {
          id: String(row.original.label),
          value: row.original.x,
        },
      ];

      const allRows = table.getRowModel().rows;
      const maxValue = Math.max(...allRows.map((r) => r.original.x));

      return (
        <div className={styles["top-ten-table__cell"]}>
          <div className={styles["top-ten-table__amount"]}>
            <HorizontalBar
              data={data}
              valueFormatter={(value) => `${value.toFixed(2)} KL`}
              height={28}
              maxValue={maxValue}
              className={styles["top-ten-table__bar"]}
            />
          </div>
        </div>
      );
    },
  },
];

help me to fix this bug
Bug Description:
When navigating from the Dashboard to the Meters page by clicking on a specific meter ID:
* The Meter dropdown and Date Range Picker correctly replicate the meter ID and date range from the Dashboard.
* However, the Clear All button does not reset the page as expected. After clicking it, the filters remain partially applied instead of resetting to the default state (like when visiting the Meters page directly).
* Additionally, changing the Meter selection should update the URL to reflect the selected meter, e.g., `meters?meter_id=312188212`, but this behavior is inconsistent in this scenario.
Expected Behavior:
1. Clicking a meter ID from the Dashboard should prefill the Meter dropdown and Date Range Picker.
2. Clicking Clear All should fully reset the filters to the default state (as if visiting the Meters page directly).
3. Changing the Meter selection should update the URL query parameter accordingly (`?meter_id=XYZ`) and update the page results.
