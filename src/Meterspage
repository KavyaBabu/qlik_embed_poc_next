"use client";

import { QueryParams } from "@arqiva/react-component-lib";
import {
  DateRangeFilter,
  dateRangeFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/DateRangeFilter";
import {
  MetersFilter,
  meterFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/MetersFilter";
import { useQueryFilterSync } from "@/hooks/useQueryFilterSync";
import KpiSummary from "./widgets/KpiSummary/page";
import MedianVsWeek from "./widgets/MedianVsWeek/page";
import LeakageHistory from "./widgets/LeakageHistory/page";
import DailyUsage from "./widgets/DailyUsage/page";
import ConsumptionTrend from "./widgets/ConsumptionTrend/page";
import styles from "./index.module.css";

export interface MetersFilters {
  meter_id?: string;
  dateRange?: string;
}

interface FiltersBarProps {
  onFiltersChange: (filters: MetersFilters) => void;
}

const FiltersBar = ({ onFiltersChange }: FiltersBarProps) => {
  const { clearAll } = useQueryFilterSync<MetersFilters>({
    storageKey: "meters-filters",
    inheritedFromStorageKey: "dashboard-filters",
    inheritKeys: ["dateRange"],
    onChange: onFiltersChange,
  });

  return (
    <div className={styles.meters__filters}>
      <QueryParams.Params.Filters>
        <MetersFilter />
        <DateRangeFilter />
      </QueryParams.Params.Filters>

      <QueryParams.Params.SelectedValues
        resultsLoading={false}
        onClearAll={clearAll}
        filterOverrides={{
          ...meterFilterOverride,
          ...dateRangeFilterOverride,
        }}
        filterIgnoreList={["q", "page", "perPage", "sortBy", "sortDir"]}
      />
    </div>
  );
};

const Content = ({ metersFilters }: { metersFilters: MetersFilters }) => (
  <section className={styles.meters}>
    <div className={styles["meters--full-width"]}>
      <KpiSummary meterId={metersFilters.meter_id} />
    </div>

    <div className={styles["meters__split-row"]}>
      <div className={styles["meters__main-column"]}>
        <h3 className={styles["meters__section-heading"]}>Consumption Trend</h3>
        <ConsumptionTrend meterId={metersFilters.meter_id} />
      </div>
      <div className={styles["meters__side-column"]}>
        <h3 className={styles["meters__section-heading"]}>
          Median vs this weeks consumption
        </h3>
        <MedianVsWeek meterId={metersFilters.meter_id} />
      </div>
    </div>

    <div className={styles["meters__split-row"]}>
      <div className={styles["meters__main-column"]}>
        <h3 className={styles["meters__section-heading"]}>Leakage History</h3>
        <LeakageHistory meterId={metersFilters.meter_id} threshold={0.5} />
      </div>
      <div className={styles["meters__side-column"]}>
        <h3 className={styles["meters__section-heading"]}>Daily Usage</h3>
        <DailyUsage meterId={metersFilters.meter_id} />
      </div>
    </div>
  </section>
);

const MetersInner = { FiltersBar, Content };
export default MetersInner;


"use client";

import { QueryParams } from "@arqiva/react-component-lib";
import { useCustomerContext } from "@/app/_components/CustomerProvider";
import {
  GroupFilter,
  groupFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/GroupFilter";
import {
  DateRangeFilter,
  dateRangeFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/DateRangeFilter";
import {
  TimeFilter,
  timeFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/TimeFilter";
import {
  ConsumptionFilter,
  consumptionFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/ConsumptionFilter";
import MeterConsumptionPage from "./widgets/meterConsumption/page";
import LeakagePage from "./widgets/leakgaeInfo/page";
import Top10MeterPage from "./widgets/top10Meters/page";
import FlowValuesInner from "./widgets/flowValues/Inner";
import { useQueryFilterSync } from "@/hooks/useQueryFilterSync";
import styles from "./index.module.css";

export interface DashboardFilters {
  group_id?: string;
  dateRange?: string;
  timeRange?: string;
  consumption_range?: string;
}

interface FiltersBarProps {
  onFiltersChange: (filters: DashboardFilters) => void;
}

const FiltersBar = ({ onFiltersChange }: FiltersBarProps) => {
  const { effectiveCustomerId } = useCustomerContext();

  const { clearAll } = useQueryFilterSync<DashboardFilters>({
    storageKey: "dashboard-filters",
    onChange: onFiltersChange,
  });

  return (
    <div className={styles.dashboard__filters}>
      <QueryParams.Params.Filters>
        <GroupFilter />
        <DateRangeFilter />
        <TimeFilter />
        <ConsumptionFilter />
      </QueryParams.Params.Filters>

      <QueryParams.Params.SelectedValues
        resultsLoading={false}
        onClearAll={clearAll}
        filterOverrides={{
          ...groupFilterOverride,
          ...dateRangeFilterOverride,
          ...timeFilterOverride,
          ...consumptionFilterOverride,
        }}
        filterIgnoreList={["q"]}
      />
    </div>
  );
};

const Content = () => (
  <section className={styles.dashboard}>
    <div className={styles["dashboard--full-width"]}>
      <h2 className={styles["dashboard__section-heading"]}>
        Meter Consumption
      </h2>
      <MeterConsumptionPage />
    </div>

    <div className={styles["dashboard--full-width"]}>
      <h2 className={styles["dashboard__section-heading"]}>Leakage</h2>
      <LeakagePage />
    </div>

    <div className={styles["dashboard__split-row"]}>
      <div className={styles["dashboard__main-column"]}>
        <h2 className={styles["dashboard__section-heading"]}>Top 10 Meters</h2>
        <Top10MeterPage />
      </div>
      <div className={styles["dashboard__side-column"]}>
        <h2 className={styles["dashboard__section-heading"]}>Flow Values</h2>
        <FlowValuesInner />
      </div>
    </div>
  </section>
);

const DashboardInner = { FiltersBar, Content };
export default DashboardInner;


"use client";

import { useEffect, useRef } from "react";
import { useQueryParams } from "@arqiva/react-component-lib";

interface UseQueryFilterSyncOptions<T extends Record<string, any>> {
  storageKey: string;
  inheritedFromStorageKey?: string;
  inheritKeys?: (keyof T)[];
  onChange: (filters: T) => void;
}

export function useQueryFilterSync<T extends Record<string, any>>({
  storageKey,
  inheritedFromStorageKey,
  inheritKeys = [],
  onChange,
}: UseQueryFilterSyncOptions<T>) {
  const { queryParams, setParam, clearAllParams } = useQueryParams();

  const hasRestoredRef = useRef(false);

  /* ---------- Restore (URL wins) ---------- */
  useEffect(() => {
    if (hasRestoredRef.current) return;

    const hasUrlFilters = Object.values(queryParams).some(Boolean);
    if (hasUrlFilters) {
      hasRestoredRef.current = true;
      return;
    }

    // Inherit from another page (Dashboard â†’ Meters)
    if (inheritedFromStorageKey) {
      try {
        const inherited = localStorage.getItem(inheritedFromStorageKey);
        if (inherited) {
          const parsed = JSON.parse(inherited);
          inheritKeys.forEach((key) => {
            if (parsed[key]) {
              setParam(String(key), parsed[key]);
            }
          });
        }
      } catch {}
    }

    // Fallback to own storage
    try {
      const stored = localStorage.getItem(storageKey);
      if (stored) {
        const parsed = JSON.parse(stored);
        Object.entries(parsed).forEach(([key, value]) => {
          if (value) setParam(key, value);
        });
      }
    } catch {}

    hasRestoredRef.current = true;
  }, [
    queryParams,
    setParam,
    storageKey,
    inheritedFromStorageKey,
    inheritKeys,
  ]);

  /* ---------- Sync + persist ---------- */
  useEffect(() => {
    const filters = Object.fromEntries(
      Object.entries(queryParams).filter(
        ([, v]) => v !== undefined && v !== null && v !== ""
      )
    ) as T;

    try {
      localStorage.setItem(storageKey, JSON.stringify(filters));
    } catch {}

    onChange(filters);
  }, [queryParams, onChange, storageKey]);

  /* ---------- Clear All ---------- */
  const clearAll = () => {
    clearAllParams();

    try {
      localStorage.removeItem(storageKey);
    } catch {}

    hasRestoredRef.current = true;
    onChange({} as T);
  };

  return { clearAll };
}
