 GET /favicon.ico?favicon.0b3bf435.ico 200 in 464ms
 тип [TypeError: Cannot read properties of null (reading 'registered')] {
  digest: '623655995'
}

Switched to client rendering because the server rendering errored:


"use client";

import { QueryParams } from "@arqiva/react-component-lib";

import {
  GroupFilter,
  groupFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/GroupFilter";
import {
  DateRangeFilter,
  dateRangeFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/DateRangeFilter";
import {
  TimeFilter,
  timeFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/TimeFilter";
import {
  ConsumptionFilter,
  consumptionFilterOverride,
} from "@/lib/services/api/dashboard/Kpis/filters/ConsumptionFilter";

import MeterConsumptionPage from "./widgets/meterConsumption/page";
import LeakagePage from "./widgets/leakgaeInfo/page";
import Top10MeterPage from "./widgets/top10Meters/page";
import FlowValuesInner from "./widgets/flowValues/Inner";
import styles from "./index.module.css";
import LeakageListPage from "./widgets/leakageList/page";

interface DashboardInnerProps {
  initialData?: unknown;
}

export const DashboardInner = (_props: DashboardInnerProps) => {
  return (
    <QueryParams.Params.Root>
      <QueryParams.Params.Filters>
        <GroupFilter />
        <DateRangeFilter />
        <TimeFilter />
        <ConsumptionFilter />
      </QueryParams.Params.Filters>
      {Object.keys(QueryParams ?? {}).length > 0 && (
        <QueryParams.Params.SelectedValues
          resultsLoading={false}
          resultsCount={0}
          filterOverrides={{
            ...groupFilterOverride,
            ...dateRangeFilterOverride,
            ...timeFilterOverride,
            ...consumptionFilterOverride,
          }}
        />
      )}
      <section className={styles.dashboard}>
        <div className={styles["dashboard--full-width"]}>
          <h2 className={styles["dashboard__section-heading"]}>
            Meter Consumption
          </h2>
          <MeterConsumptionPage />
        </div>

        <div className={styles["dashboard--full-width"]}>
          <h2 className={styles["dashboard__section-heading"]}>Leakage</h2>
          <LeakagePage />
        </div>

        <div className={styles["dashboard__split-row"]}>
          <div className={styles["dashboard__main-column"]}>
            <h2 className={styles["dashboard__section-heading"]}>
              Top 10 Meters
            </h2>
            <Top10MeterPage />
          </div>

          <div className={styles["dashboard__side-column"]}>
            <h2 className={styles["dashboard__section-heading"]}>
              Flow Values
            </h2>
            <FlowValuesInner />
          </div>
        </div>

        <div className={styles["dashboard--full-width"]}>
          <h2 className={styles["dashboard__section-heading"]}>Leakage List</h2>
          <LeakageListPage />
        </div>
      </section>
    </QueryParams.Params.Root>
  );
};

export default DashboardInner;

"use client";

import LeakageListInner from "./Inner";

export default function LeakageListPage() {
  return <LeakageListInner />;
}


"use client";

import { useMemo } from "react";
import { QueryParams, useQueryParams } from "@arqiva/react-component-lib";
import SearchQueryFilter, {
  searchQueryFilterOverride,
} from "@/lib/services/common/SearchQueryFilter";
import { LeakageList } from "@/lib/services/api/dashboard/Kpis/components/Leakage/List";
import {
  mapKpiQueryParams,
  buildLeakageApiRequest,
} from "@/lib/services/api/dashboard/Kpis/utils/queryParamMapper";
import { LeakageListRequest } from "@/lib/services/api/dashboard/Kpis/models/getLeakageList";

export default function LeakageListInner() {
  const { queryParams } = useQueryParams<LeakageListRequest>();

  const queryParameters = useMemo(() => {
    const mapped = mapKpiQueryParams(queryParams, "leakage");
    return buildLeakageApiRequest(mapped);
  }, [queryParams]);

  return (
    <LeakageList queryParameters={queryParameters}>
      {({ resultsLoading, resultsCount }) => (
        <QueryParams.Params.Root>
          <SearchQueryFilter placeholder="Search" />
          <QueryParams.Params.SelectedValues
            resultsLoading={resultsLoading}
            resultsCount={resultsCount}
            filterOverrides={searchQueryFilterOverride}
          />
        </QueryParams.Params.Root>
      )}
    </LeakageList>
  );
}


export * from "./List";
export * from "./columns";
export * from "./searchParams";
export * from "./queryParameters";


"use client";

import {
  Table,
  DataTable,
  QueryParams,
  getPaginationPropsFromQuery,
} from "@arqiva/react-component-lib";
import { leakageColumns } from "./columns";
import type {
  LeakageListResponse,
  LeakageListRequest,
} from "../../../models/getLeakageList";
import { useLeakageList } from "../../../hooks/useLeakageList";
import { isQueryLoading } from "@/utils/query/isQueryLoading";
import Error from "@/lib/services/api/_components/Error";

interface ListProps {
  queryParameters: LeakageListRequest;
  initialData?: LeakageListResponse;
  children?: ({
    resultsLoading,
    resultsCount,
  }: {
    resultsLoading: boolean;
    resultsCount: number;
  }) => React.ReactNode;
}

export const LeakageList = ({
  queryParameters,
  initialData,
  children,
}: ListProps) => {
  const query = useLeakageList({
    queryParameters,
    initialData,
  });

  if (query.error) {
    return (
      <Error error={query.error as Error} refetchOptions={query.refetch} />
    );
  }

  const isLoading = isQueryLoading(query);

  return (
    <Table.Wrapper>
      {children?.({
        resultsLoading: isLoading,
        resultsCount: query.data?.totalItems ?? 0,
      })}

      <DataTable
        columns={leakageColumns}
        data={query.data?.data ?? []}
        isLoading={isLoading}
        loader={{
          pageLength: queryParameters.perPage,
          widths: ["md", "lg"],
        }}
        sortByComponent={(column) => <QueryParams.Table.Sort column={column} />}
        paginationComponent={
          <QueryParams.Table.Pagination
            {...getPaginationPropsFromQuery(
              query,
              queryParameters?.perPage ?? 10
            )}
          />
        }
      />
    </Table.Wrapper>
  );
};

export default LeakageList;

import { UseQueryOptions } from "@tanstack/react-query";
import { useInitialCachedQuery } from "@/hooks/useInitialCachedQuery";
import KpiService from "../api";

import {
  LeakageListRequest,
  LeakageListResponse,
} from "../models/getLeakageList";

interface UseLeakageListProps
  extends Omit<UseQueryOptions<LeakageListResponse>, "queryKey" | "queryFn"> {
  queryParameters?: LeakageListRequest;
}

export const useLeakageList = (props: UseLeakageListProps = {}) => {
  const { queryParameters, initialData, ...restProps } = props;

  const query = useInitialCachedQuery({
    initialData,
    queryParameters,
    queryKey: ["leakageList", queryParameters],
    queryFn: () => KpiService.leakageList(queryParameters!),
    ...restProps,
  });

  return query;
};


import { apiClient } from "../setup";
import { withErrorHandling } from "../shared";
import {
  kpiConsumptionQuerySchema,
  kpiConsumptionResponseSchema,
  type KpiConsumptionQuery,
  type KpiConsumptionResponse,
} from "../Kpis/models/getKpiConsumption";

import {
  kpiLeakageQuerySchema,
  kpiLeakageResponseSchema,
  type KpiLeakageQuery,
  type KpiLeakageResponse,
} from "../Kpis/models/getKpiLeakage";

import {
  top10MetersRequestSchema,
  top10MetersResponseSchema,
  type Top10MetersRequest,
  type Top10MetersResponse,
} from "../Kpis/models/getTop10Meters";

import {
  flowValuesRequestSchema,
  flowValuesResponseSchema,
  type FlowValuesRequest,
  type FlowValuesResponse,
} from "../Kpis/models/getFlowValues";

import {
  leakageListRequestSchema,
  leakageListResponseSchema,
  type LeakageListRequest,
  type LeakageListResponse,
} from "../Kpis/models/getLeakageList";

const KpiService = {
  async consumption(
    query: KpiConsumptionQuery
  ): Promise<KpiConsumptionResponse> {
    kpiConsumptionQuerySchema.parse(query);

    const response = await withErrorHandling(
      () =>
        apiClient.GET("/kpis", {
          params: { query },
        }),
      {
        endpoint: "/kpis",
        operation: "getKpiConsumption",
      }
    );

    return kpiConsumptionResponseSchema.parse(response);
  },

  async leakage(query: KpiLeakageQuery): Promise<KpiLeakageResponse> {
    kpiLeakageQuerySchema.parse(query);

    const response = await withErrorHandling(
      () =>
        apiClient.GET("/kpis/leakage", {
          params: { query },
        }),
      {
        endpoint: "/kpis/leakage",
        operation: "getKpiLeakage",
      }
    );

    return kpiLeakageResponseSchema.parse(response);
  },
  async listTop10(body: Top10MetersRequest): Promise<Top10MetersResponse> {
    top10MetersRequestSchema.parse(body);

    const response = await withErrorHandling(
      () => apiClient.POST("/top10_meters", { body }),
      {
        endpoint: "/top10_meters",
        operation: "listTop10Meters",
      }
    );

    return top10MetersResponseSchema.parse(response);
  },
  async flowValues(body: FlowValuesRequest): Promise<FlowValuesResponse> {
    flowValuesRequestSchema.parse(body);

    const response = await withErrorHandling(
      () => apiClient.POST("/flow_values", { body }),
      {
        endpoint: "/flow_values",
        operation: "listFlowValues",
      }
    );

    return flowValuesResponseSchema.parse(response);
  },

  async leakageList(body: LeakageListRequest): Promise<LeakageListResponse> {
    leakageListRequestSchema.parse(body);

    const response = await withErrorHandling(
      () =>
        apiClient.POST("/kpis/table", {
          body,
        }),
      {
        endpoint: "/kpis/table",
        operation: "listLeakageList",
      }
    );

    return leakageListResponseSchema.parse(response);
  },
};

export default KpiService;

"use client";

import { ColumnDef } from "@tanstack/react-table";
import type { LeakageListEntry } from "../../../models/getLeakageList";
import {
  Table,
  TruncatedText,
  Button,
  Badge,
} from "@arqiva/react-component-lib";
import Link from "next/link";

export const leakageColumns: ColumnDef<LeakageListEntry>[] = [
  {
    id: "meter_id",
    header: "Meter",
    accessorKey: "meter_id",
    enableSorting: true,
    cell: ({ row }) => {
      return (
        <Table.Block.Lead>
          <Button variant="text" asChild>
            <Link href={`/dashboard/leakage/${row.original.meter_id}`}>
              <TruncatedText text={String(row.original.meter_id)} />
            </Link>
          </Button>
        </Table.Block.Lead>
      );
    },
  },
  {
    id: "usage",
    header: "Usage",
    accessorKey: "usage",
    enableSorting: true,
    cell: ({ row }) => {
      const val = String(row.original.usage).toLowerCase();

      const variant =
        val === "high" ? "error" : val === "medium" ? "warning" : "success";

      return <Badge variant={variant}>{row.original.usage}</Badge>;
    },
  },
  {
    id: "daily_avg_consumption",
    header: "Daily Avg Consumption",
    accessorKey: "daily_avg_consumption",
    enableSorting: true,
  },
  {
    id: "hourly_avg_consumption",
    header: "Hourly Avg Consumption",
    accessorKey: "hourly_avg_consumption",
    enableSorting: true,
  },
  {
    id: "total_consumption",
    header: "Reading Amount",
    accessorKey: "total_consumption",
    enableSorting: true,
    cell: ({ row }) => {
      return <Badge variant="warning">{row.original.total_consumption}</Badge>;
    },
  },
];


import { LeakageListRequest } from "../../../models/getLeakageList";

export const parseQueryParameters = (
  params?: Partial<LeakageListRequest>
): LeakageListRequest => {
  const now = new Date();
  const oneYearAgo = new Date(now.setFullYear(now.getFullYear() - 1));

  return {
    group_id: params?.group_id ?? 0,

    start_datetime: params?.start_datetime ?? oneYearAgo.toISOString(),

    end_datetime: params?.end_datetime ?? new Date().toISOString(),

    min_consumption: params?.min_consumption ?? 0,
    max_consumption: params?.max_consumption ?? 10_000_000_000,

    q: params?.q?.trim() ?? "",

    page: params?.page ?? 0,
    perPage: params?.perPage ?? 10,

    sortBy: params?.sortBy ?? "meter_id",
    sortDir: params?.sortDir ?? "asc",

    threshold: params?.threshold ?? 0.5,
  };
};


import * as z from "zod/v4";

export const leakageListRequestSchema = z.object({
  group_id: z.coerce.number(),
  start_datetime: z.string(),
  end_datetime: z.string(),
  min_consumption: z.number(),
  max_consumption: z.number(),
  q: z.string(),
  page: z.number(),
  perPage: z.coerce.number(),
  sortBy: z.enum([
    "meter_id",
    "hourly_avg_consumption",
    "daily_avg_consumption",
    "total_consumption",
  ]),
  sortDir: z.enum(["asc", "desc"]),
  threshold: z.number(),
});
export type LeakageListRequest = z.infer<typeof leakageListRequestSchema>;

export const leakageReadingSchema = z.object({
  reading: z.number(),
  expected: z.number(),
  status: z.string(),
});

export const leakageListEntrySchema = z.object({
  meter_id: z.number(),
  usage: z.string(),
  hourly_avg_consumption: z.number(),
  total_consumption: z.number(),
  daily_avg_consumption: z.number(),
  leaks: z.boolean(),
  meter_reading: z.array(leakageReadingSchema),
});
export type LeakageListEntry = z.infer<typeof leakageListEntrySchema>;

export const leakageListResponseSchema = z.object({
  data: z.array(leakageListEntrySchema),
  count: z.number(),
  page: z.number(),
  perPage: z.number(),
  totalItems: z.number(),
  totalPages: z.number(),
});

export type LeakageListResponse = z.infer<typeof leakageListResponseSchema>;

import { SearchParams } from "@/utils/pageTypes";
import {
  LeakageListRequest,
  LeakageListRequest as LeakageListQueryParams,
} from "../../../models/getLeakageList";

const getStringParam = (val: string | string[] | undefined) => {
  return Array.isArray(val) ? val[0] : val;
};

export const parseSearchParams = (
  params: SearchParams
): LeakageListQueryParams => {
  return {
    group_id: Number(getStringParam(params.group_id) ?? 0),

    start_datetime:
      getStringParam(params.start_datetime) ??
      new Date(
        new Date().setFullYear(new Date().getFullYear() - 1)
      ).toISOString(),

    end_datetime:
      getStringParam(params.end_datetime) ?? new Date().toISOString(),

    min_consumption: Number(getStringParam(params.min_consumption) ?? 0),
    max_consumption: Number(
      getStringParam(params.max_consumption) ?? 10_000_000_000
    ),

    q: getStringParam(params.q) ?? "",

    page: Number.parseInt(getStringParam(params.page) ?? "0", 10),
    perPage: Number.parseInt(getStringParam(params.perPage) ?? "10", 10),

    sortBy:
      (getStringParam(params.sortBy) as LeakageListRequest["sortBy"]) ??
      "meter_id",

    sortDir:
      (getStringParam(params.sortDir) as LeakageListRequest["sortDir"]) ??
      "asc",

    threshold: Number(getStringParam(params.threshold) ?? 0.5),
  };
};


queryParamMapper

function todayStartISO() {
  const d = new Date();
  d.setHours(0, 0, 0, 0);
  return d.toISOString();
}

function todayEndISO() {
  const d = new Date();
  d.setHours(23, 59, 59, 999);
  return d.toISOString();
}

interface BaseKpiParams {
  group_id: number;
  start_datetime: string;
  end_datetime: string;
}

interface ConsumptionListParams extends BaseKpiParams {
  min_consumption: number;
  max_consumption: number;
  threshold: number;
}

interface StandardMinMaxParams extends BaseKpiParams {
  min_consumption: number;
  max_consumption: number;
}

interface MinMaxWithSortParams extends StandardMinMaxParams {
  sortKey?: string;
  sortOrder?: string;
}

interface Top10MetersParams extends StandardMinMaxParams {
  threshold: number;
}

interface LeakageListParams extends StandardMinMaxParams {
  q?: string;
  page?: number;
  perPage?: number;
  threshold?: number;
  sortKey?: string;
  sortOrder?: string;
}

function parseCommonParams(queryParams: Record<string, unknown>) {
  const qp = queryParams as Record<string, unknown>;

  const group_id = Number(qp.group_id ?? qp.group ?? 0);

  const dateRange = typeof qp.dateRange === "string" ? qp.dateRange : "";
  const [startStr, endStr] = dateRange.split("_to_");

  const start_datetime =
    startStr && !Number.isNaN(Date.parse(startStr))
      ? startStr
      : todayStartISO();
  const end_datetime =
    endStr && !Number.isNaN(Date.parse(endStr)) ? endStr : todayEndISO();

  const range =
    typeof qp.consumption_range === "string"
      ? qp.consumption_range
      : "0-10000000000";

  const [lo, hi] = (range as string).split("-").map(Number);

  return {
    group_id,
    start_datetime,
    end_datetime,
    minConsumption: Number.isFinite(lo) ? lo : 0,
    maxConsumption: Number.isFinite(hi) ? hi : 10_000_000_000,
  };
}

export function mapKpiQueryParams(
  queryParams: Record<string, unknown>,
  variant: "cons"
): ConsumptionListParams;

export function mapKpiQueryParams(
  queryParams: Record<string, unknown>,
  variant: "minmax"
): MinMaxWithSortParams;

export function mapKpiQueryParams(
  queryParams: Record<string, unknown>,
  variant: "top10"
): Top10MetersParams;

export function mapKpiQueryParams(
  queryParams: Record<string, unknown>,
  variant: "leakage"
): LeakageListParams;

export function mapKpiQueryParams(
  queryParams: Record<string, unknown>,
  variant?: "cons" | "minmax" | "top10" | "leakage"
):
  | ConsumptionListParams
  | MinMaxWithSortParams
  | Top10MetersParams
  | LeakageListParams {
  const qp = queryParams as Record<string, unknown>;
  const {
    group_id,
    start_datetime,
    end_datetime,
    minConsumption,
    maxConsumption,
  } = parseCommonParams(qp);

  if (variant === "cons") {
    return {
      group_id,
      start_datetime,
      end_datetime,
      min_consumption: minConsumption,
      max_consumption: maxConsumption,
      threshold: 0.5,
    } satisfies ConsumptionListParams;
  }

  if (variant === "top10") {
    return {
      group_id,
      start_datetime,
      end_datetime,
      min_consumption: minConsumption,
      max_consumption: maxConsumption,
      threshold: 0.5,
    } satisfies Top10MetersParams;
  }

  if (variant === "leakage") {
    return {
      group_id,
      start_datetime,
      end_datetime,
      min_consumption: minConsumption,
      max_consumption: maxConsumption,
      q: typeof qp.q === "string" ? qp.q : "",
      page: typeof qp.page === "number" ? qp.page : 0,
      perPage: typeof qp.perPage === "number" ? qp.perPage : 10,
      threshold: typeof qp.threshold === "number" ? qp.threshold : 0.5,
      sortKey:
        typeof qp.sortBy === "string"
          ? qp.sortBy
          : typeof qp.sortKey === "string"
            ? qp.sortKey
            : "meter_id",
      sortOrder:
        typeof qp.sortDir === "string"
          ? qp.sortDir
          : typeof qp.sortOrder === "string"
            ? qp.sortOrder
            : "asc",
    } satisfies LeakageListParams;
  }

  return {
    group_id,
    start_datetime,
    end_datetime,
    min_consumption: minConsumption,
    max_consumption: maxConsumption,
    sortKey: (qp.sortKey as string) ?? "meter_id",
    sortOrder: (qp.sortOrder as string) ?? "ascend",
  } satisfies MinMaxWithSortParams;
}

type SortKey =
  | "meter_id"
  | "hourly_avg_consumption"
  | "daily_avg_consumption"
  | "total_consumption";

export const buildLeakageApiRequest = (mappedParams: LeakageListParams) => {
  return {
    group_id: mappedParams.group_id,
    start_datetime: mappedParams.start_datetime,
    end_datetime: mappedParams.end_datetime,
    min_consumption: mappedParams.min_consumption,
    max_consumption: mappedParams.max_consumption,
    q: mappedParams.q ?? "",
    page: mappedParams.page ?? 0,
    perPage: mappedParams.perPage ?? 10,
    threshold: mappedParams.threshold ?? 0.5,
    sortBy: (mappedParams.sortKey ?? "meter_id") as SortKey,
    sortDir: (mappedParams.sortOrder ?? "asc") as "asc" | "desc",
  };
};


