import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
  CartesianGrid,
  ReferenceDot,
  ReferenceLine,
  Area,
  ReferenceArea,
} from 'recharts';
import { useState, useMemo } from 'react';
import ChartTooltip from '../ChartToolTip';
import ChartLegend from '../ChartLegend';
import { LegendItem } from '../ChartLegend/types';
import styles from './index.module.css';

export interface LineChartDataPoint {
  [key: string]: string | number | null;
}

export interface LineChartProps {
  data: LineChartDataPoint[];
  solidLineKey: string;
  dottedLineKey: string;
  missingKey?: string;
  valueFormatter?: (value: number | string | null | undefined) => string;
  xAxisKey?: string;
  xAxisLabel?: string;
  yAxisLabel?: string;
  height?: number;
  showGrid?: boolean;
  showLegend?: boolean;
  className?: string;
  title?: string;
  subtitle?: string;
  solidLineLabel?: string;
  dottedLineLabel?: string;
  missingLabel?: string;
  solidLineColor?: string;
  dottedLineColor?: string;
  missingColor?: string; // legend color (and can be reused for fill if you want)
  showHoverLine?: boolean;
  hoverLineColor?: string;
  thirdLegendItem?: {
    label: string;
    color?: string;
  };
}

type FilledPoint = LineChartDataPoint & {
  solidValue: number | null;
  dottedValue: number | null;
  upper: number | null;
  lower: number | null;
  hasMissing: boolean;

  // ✅ used to fill only the missing segments between the two lines
  missingUpper: number | null;
  missingLower: number | null;
};

const toNumOrNull = (v: unknown): number | null => {
  if (v === null || v === undefined) return null;
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
};

const LineChartComponent = ({
  data,
  solidLineKey,
  dottedLineKey,
  missingKey = 'missing',
  valueFormatter = (v) => `${Number(v || 0).toFixed(0)} KL`,
  xAxisKey = 'name',
  xAxisLabel = 'Period',
  yAxisLabel = 'Value',
  height = 320,
  showGrid = true,
  showLegend = true,
  className,
  title,
  subtitle,
  solidLineLabel,
  dottedLineLabel,
  missingLabel = 'Missing',
  solidLineColor = 'primary-600',
  dottedLineColor = 'error-600',
  missingColor = 'warning-600',
  showHoverLine = true,
  hoverLineColor = 'error-700',
  thirdLegendItem,
}: LineChartProps) => {
  const [hovered, setHovered] = useState<{
    x: string | number;
    y: number;
    hasMissing: boolean;
  } | null>(null);

  const { filledData, missingRanges } = useMemo(() => {
    const filled: FilledPoint[] = data.map((d) => {
      const solidValue = toNumOrNull(d[solidLineKey]);
      const dottedValue = toNumOrNull(d[dottedLineKey]);

      const values = [solidValue, dottedValue].filter(
        (v): v is number => v !== null && Number.isFinite(v),
      );

      const upper = values.length ? Math.max(...values) : null;
      const lower = values.length ? Math.min(...values) : null;

      const hasMissing = d[missingKey] !== null && d[missingKey] !== undefined;

      return {
        ...d,
        solidValue,
        dottedValue,
        upper,
        lower,
        hasMissing,

        // ✅ only populate these when missing exists
        missingUpper: hasMissing ? upper : null,
        missingLower: hasMissing ? lower : null,
      };
    });

    // Find missing data ranges for background highlighting
    const ranges: Array<{ start: number; end: number }> = [];
    let rangeStart: number | null = null;

    filled.forEach((point, idx) => {
      if (point.hasMissing) {
        if (rangeStart === null) rangeStart = idx;
      } else {
        if (rangeStart !== null) {
          ranges.push({ start: rangeStart, end: idx - 1 });
          rangeStart = null;
        }
      }
    });

    if (rangeStart !== null) {
      ranges.push({ start: rangeStart, end: filled.length - 1 });
    }

    return { filledData: filled, missingRanges: ranges };
  }, [data, solidLineKey, dottedLineKey, missingKey]);

  const legendItems: LegendItem[] = useMemo(() => {
    const items: LegendItem[] = [
      {
        dataKey: solidLineKey,
        label: solidLineLabel || solidLineKey,
        color: `rgb(var(--${solidLineColor}-base))`,
      },
      {
        dataKey: dottedLineKey,
        label: dottedLineLabel || dottedLineKey,
        color: `rgb(var(--${dottedLineColor}-base))`,
      },
    ];

    if (thirdLegendItem) {
      items.push({
        dataKey: 'reference',
        label: thirdLegendItem.label,
        color: thirdLegendItem.color || `rgb(var(--${hoverLineColor}-base))`,
      });
    } else {
      const hasMissingData = filledData.some((d) => d.hasMissing);
      if (hasMissingData) {
        items.push({
          dataKey: missingKey,
          label: missingLabel,
          color: `rgb(var(--${missingColor}-base))`,
        });
      }
    }

    return items;
  }, [
    solidLineKey,
    dottedLineKey,
    solidLineLabel,
    dottedLineLabel,
    solidLineColor,
    dottedLineColor,
    thirdLegendItem,
    hoverLineColor,
    missingKey,
    missingLabel,
    missingColor,
    filledData,
  ]);

  return (
    <div className={`${styles.container} ${className || ''}`}>
      <div className={styles.header}>
        <div className={styles.header__content}>
          {title && <h3 className={styles.title}>{title}</h3>}
          {subtitle && <p className={styles.subtitle}>{subtitle}</p>}
        </div>
        {showLegend && (
          <div className={styles.header__legend}>
            <ChartLegend items={legendItems} />
          </div>
        )}
      </div>

      <div className={styles.wrapper}>
        <ResponsiveContainer width="100%" height={height}>
          <LineChart
            data={filledData}
            margin={{ top: 20, right: 40, left: 40, bottom: 60 }}
            onMouseMove={(e) => {
              const idx = e?.activeTooltipIndex;
              if (idx === undefined || idx === null) {
                setHovered(null);
                return;
              }

              const safeIdx = Number(idx);
              if (!Number.isFinite(safeIdx) || safeIdx < 0 || safeIdx >= filledData.length) {
                setHovered(null);
                return;
              }

              const point = filledData[safeIdx];
              const solidValue = point.solidValue;

              // If solidValue is null, don't draw hover marker/line
              if (solidValue === null) {
                setHovered(null);
                return;
              }

              setHovered({
                x: point[xAxisKey as keyof LineChartDataPoint] as string | number,
                y: solidValue,
                hasMissing: point.hasMissing,
              });
            }}
            onMouseLeave={() => setHovered(null)}
          >
            {showGrid && (
              <CartesianGrid
                strokeDasharray="0"
                stroke="rgb(var(--grey-200-base))"
                horizontal
                vertical={false}
              />
            )}

            <XAxis
              dataKey={xAxisKey}
              tick={{ fill: 'rgb(var(--grey-600-base))', fontSize: 12 }}
              axisLine={false}
              tickLine={false}
              dy={8}
              height={40}
              label={{
                value: xAxisLabel,
                position: 'insideBottom',
                dy: 40,
                fill: 'rgb(var(--grey-600-base))',
                fontSize: 16,
              }}
            />

            <YAxis
              tick={{ fill: 'rgb(var(--grey-600-base))', fontSize: 12 }}
              axisLine={false}
              tickLine={false}
              dx={-8}
              label={{
                value: yAxisLabel,
                angle: -90,
                position: 'insideLeft',
                dy: height / 3.3,
                dx: -20,
                fill: 'rgb(var(--grey-600-base))',
                fontSize: 16,
              }}
            />

            <defs>
              <linearGradient id="bandFill" x1="0" y1="0" x2="0" y2="1">
                <stop
                  offset="0%"
                  stopColor={`rgb(var(--${solidLineColor}-base))`}
                  stopOpacity={0.08}
                />
                <stop
                  offset="100%"
                  stopColor={`rgb(var(--${solidLineColor}-base))`}
                  stopOpacity={0.03}
                />
              </linearGradient>

              {/* ✅ optional: light missing fill (adjust token if you have warning-200, warning-100 etc.) */}
              <linearGradient id="missingBandFill" x1="0" y1="0" x2="0" y2="1">
                <stop
                  offset="0%"
                  stopColor="rgb(var(--warning-200-base))"
                  stopOpacity={0.45}
                />
                <stop
                  offset="100%"
                  stopColor="rgb(var(--warning-200-base))"
                  stopOpacity={0.25}
                />
              </linearGradient>
            </defs>

            {/* Missing data background highlights (banded to data range, not full chart height) */}
            {missingRanges.map((range, idx) => {
              const x1 = filledData[range.start]?.[xAxisKey] as string | number | undefined;
              const x2 = filledData[range.end]?.[xAxisKey] as string | number | undefined;

              if (x1 === undefined || x2 === undefined) return null;

              const rangeData = filledData.slice(range.start, range.end + 1);

              // Collect real numeric values only (do NOT coerce null to 0)
              const allValues = rangeData
                .flatMap((d) => [d.solidValue, d.dottedValue])
                .filter((v): v is number => v !== null && Number.isFinite(v));

              // If no values exist in this range, don't render
              if (allValues.length === 0) return null;

              const maxValue = Math.max(...allValues);
              const minValue = Math.min(...allValues);

              const span = Math.max(maxValue - minValue, 1);
              const padding = span * 0.2;

              const y1 = minValue - padding;
              const y2 = maxValue + padding;

              return (
                <ReferenceArea
                  key={`missing-${idx}`}
                  x1={x1}
                  x2={x2}
                  y1={y1}
                  y2={y2}
                  fill={`rgb(var(--${missingColor}-base))`}
                  fillOpacity={0.12}
                  ifOverflow="extendDomain"
                />
              );
            })}

            {/* Band between the two series (normal band) */}
            <Area
              dataKey="upper"
              stroke="none"
              fill="url(#bandFill)"
              baseLine={filledData.map((d) => d.lower ?? d.upper ?? 0) as unknown as readonly any[]}
              isAnimationActive={false}
              connectNulls={false}
            />

            {/* ✅ Missing fill BETWEEN consumption & leakage ONLY for missing segments */}
            <Area
              dataKey="missingUpper"
              stroke="none"
              fill="url(#missingBandFill)"
              isAnimationActive={false}
              connectNulls={false}
              baseLine={
                filledData.map((d) => (d.hasMissing ? d.missingLower : null)) as unknown as readonly any[]
              }
            />

            <Tooltip
              cursor={false}
              content={(props) => {
                if (!props.payload || props.payload.length === 0) return null;

                const solidData = props.payload.find((item) => item.dataKey === solidLineKey);
                const dottedData = props.payload.find((item) => item.dataKey === dottedLineKey);
                const currentData = props.payload[0]?.payload as FilledPoint | undefined;

                const tooltipPayload: Array<{
                  dataKey: string;
                  name: string;
                  value: number;
                  color: string;
                }> = [];

                if (solidData) {
                  tooltipPayload.push({
                    dataKey: solidLineKey,
                    name: solidLineLabel || solidLineKey,
                    value: Number(solidData.value ?? 0),
                    color: `rgb(var(--${solidLineColor}-base))`,
                  });
                }

                if (dottedData) {
                  tooltipPayload.push({
                    dataKey: dottedLineKey,
                    name: dottedLineLabel || dottedLineKey,
                    value: Number(dottedData.value ?? 0),
                    color: `rgb(var(--${dottedLineColor}-base))`,
                  });
                }

                // Add missing data to tooltip if present
                if (currentData?.hasMissing && currentData[missingKey] !== null) {
                  tooltipPayload.push({
                    dataKey: missingKey,
                    name: missingLabel,
                    value: Number(currentData[missingKey] ?? 0),
                    color: `rgb(var(--${missingColor}-base))`,
                  });
                }

                return (
                  <ChartTooltip
                    active={props.active}
                    payload={tooltipPayload}
                    label={String(props.label)}
                    variant="multi"
                    valueFormatter={valueFormatter}
                  />
                );
              }}
            />

            <Line
              type="monotone"
              dataKey={solidLineKey}
              stroke={`rgb(var(--${solidLineColor}-base))`}
              strokeWidth={2}
              dot={false}
              isAnimationActive={false}
              connectNulls={false}
            />

            <Line
              type="monotone"
              dataKey={dottedLineKey}
              stroke={`rgb(var(--${dottedLineColor}-base))`}
              strokeWidth={2}
              strokeDasharray="3 6"
              dot={false}
              isAnimationActive={false}
              connectNulls={false}
            />

            {showHoverLine && hovered && (
              <>
                <ReferenceLine
                  segment={[
                    { x: hovered.x, y: hovered.y },
                    { x: hovered.x, y: 0 },
                  ]}
                  stroke={`rgb(var(--${hoverLineColor}-base))`}
                  strokeDasharray="3 6"
                  strokeWidth={1.5}
                />
                <ReferenceDot
                  x={hovered.x}
                  y={hovered.y}
                  r={5}
                  fill="white"
                  stroke={`rgb(var(--${hoverLineColor}-base))`}
                  strokeWidth={2}
                />
              </>
            )}
          </LineChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
};

export default LineChartComponent;
